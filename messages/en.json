{
  "nav": {
    "home": "Home",
    "blog": "Blog",
    "algorithms": "Algorithms",
    "links": "Links"
  },
  "footer": {
    "copyright": "©2025 Rizwanul Islam Rudra"
  },
  "home": {
    "eyebrow": "Software Engineer · Technical Lead",
    "title": "Rizwanul Islam Rudra",
    "subtitle": "Focused on scalable systems, human-centered UX, and high-trust engineering culture.",
    "ctaPrimary": "Read the blog",
    "ctaSecondary": "Useful links",
    "focusTitle": "Focus Areas",
    "focusBody": "Engineering, design, and product strategy working together to solve real problems.",
    "capabilitiesTitle": "Capabilities",
    "capabilitiesBody": "Strengthening teams and making complex software feel clear and usable.",
    "experienceTitle": "Experience",
    "experienceBody": "Hands-on leadership across scaling systems and growing teams."
  },
  "blog": {
    "title": "Writing",
    "subtitle": "Thoughts on architecture, leadership, and building reliable products."
  },
  "links": {
    "title": "Useful Links",
    "subtitle": "Resources I keep coming back to."
  },
  "dsa": {
    "title": "Data Structures & Algorithms",
    "lead": "Algorithms are not magic tricks or obscure math; they are human ways of thinking made precise. If you have ever organized a bookshelf, planned a route, or prioritized tasks, you have already used algorithmic thinking. This page is a long‑form, plain‑language walk through the ideas that make software fast, reliable, and understandable.",
    "body1": "Start with data structures, because they shape everything that comes after. When you choose an array, you are saying, \"I want fast access by index and I know the size matters.\" A linked list says, \"I will trade random access for cheap insertions.\" A stack is a promise that the last thing in is the first thing out, which feels natural for undo buttons and parsing code. A queue mirrors real life lines: first in, first out, perfect for scheduling and tasks. A hash map is a shortcut: you pay a little extra memory to get near‑instant lookups by key, which is why caches and dictionaries love it. Trees organize hierarchy and allow fast searching with order; heaps keep the most important item at the top, which powers priority queues. Graphs are the map of relationships: routes, recommendations, dependencies. Choosing the right structure is often 80 percent of a good solution, because it turns a hard problem into a simple one. Ask yourself: what operations happen most, and what can be slow without hurting the user?",
    "body2": "Now to algorithms: think of them as playbooks with steps that always work. The human way to build one is to explore small examples first. What does the input look like? What does a correct answer look like? Can you solve a tiny case with a pencil? From there, choose a strategy. Greedy algorithms make the best local choice each step; they are fast and elegant when the problem has the right structure. Divide and conquer splits a big task into smaller versions of itself, like sorting or searching. Dynamic programming is about remembering what you already solved so you do not do the same work twice. Graph search (BFS, DFS, Dijkstra) models the world as nodes and edges, then explores it systematically. Each strategy comes with a mental model: greedy is \"make a good choice now,\" divide and conquer is \"solve smaller copies,\" dynamic programming is \"store results,\" and graph search is \"explore the space.\" Finally, we ask about complexity: if the input doubles, does the work double, or explode? Big‑O is just a compact way to answer that question.",
    "body3": "This section is designed to be interactive and practical. When you read a topic, pause and predict the next step. If I say \"use a heap,\" ask why a heap beats sorting for this case. If I say \"BFS,\" ask what property of the problem makes breadth‑first the right answer. I will include small prompts like: what changes if the input is streaming, or if you can only store part of the data in memory? What if the data is almost sorted? What if you need results in real time? The goal is not to memorize tricks, but to build judgment: the habit of translating real problems into the right structures and strategies. When you finish an explanation, you should be able to explain it back in your own words and then implement it confidently. That is what algorithmic mastery looks like in human language."
  }
}
